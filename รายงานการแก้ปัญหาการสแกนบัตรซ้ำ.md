# รายงานการแก้ปัญหาการสแกนบัตรซ้ำในระบบ RFID รถโรงเรียน

## สรุปปัญหา
ในระบบ RFID ของรถโรงเรียน พบปัญหานักเรียนแตะบัตรสแกนซ้ำในขาไปหรือขากลับ ซึ่งอาจทำให้เกิดข้อมูลที่ไม่ถูกต้องในระบบติดตามการขึ้น-ลงรถ

## วิธีการแก้ปัญหาที่ใช้ในระบบ

### 1. การป้องกันการสแกนซ้ำในระดับฮาร์ดแวร์ (Hardware Level)

#### 1.1 Deduplication Timer
```cpp
// กันพิมพ์/ส่งซ้ำบัตรเดิมเร็วไป
if (uid == lastUID && (now - lastScanMs) < DEDUP_MS) {
    rfid.PICC_HaltA();
    rfid.PCD_StopCrypto1();
    return;
}
lastUID = uid;
lastScanMs = now;
```

**หลักการทำงาน:**
- เก็บ UID ของบัตรล่าสุดที่สแกน
- ตรวจสอบเวลาที่ผ่านไปตั้งแต่การสแกนครั้งล่าสุด
- หากเป็นบัตรเดิมและเวลาที่ผ่านไปน้อยกว่า `DEDUP_MS` (ค่าที่กำหนด) จะไม่ประมวลผลการสแกน

#### 1.2 Card Removal Detection
```cpp
// รอจนยกบัตรออก + รีเซ็ตพร้อมใบถัดไป
rfid.PICC_HaltA();
rfid.PCD_StopCrypto1();
waitForCardRemoval();
resetRC522();
lastUID = "";
```

**หลักการทำงาน:**
- บังคับให้ยกบัตรออกก่อนที่จะสแกนบัตรใหม่
- รีเซ็ต RFID reader เพื่อเตรียมพร้อมสำหรับการสแกนครั้งถัดไป

### 2. การป้องกันการสแกนซ้ำในระดับฐานข้อมูล (Database Level)

#### 2.1 ตรวจสอบการสแกนซ้ำในฟังก์ชัน record_rfid_scan
```sql
-- ตรวจสอบว่ามีการสแกนในวันเดียวกันและ trip_phase เดียวกันแล้วหรือไม่
SELECT COUNT(*) INTO v_existing_scan
FROM rfid_scan_logs 
WHERE student_id = v_student_id 
    AND driver_id = p_driver_id
    AND DATE(scan_timestamp AT TIME ZONE 'Asia/Bangkok') = v_today
    AND trip_phase = v_trip_phase
    AND is_valid_scan = true;

-- ถ้ามีการสแกนแล้ว ให้ส่งข้อความแจ้งเตือน
IF v_existing_scan > 0 THEN
    RETURN json_build_object(
        'success', false,
        'error', 'นักเรียนคนนี้ได้สแกนบัตรในเส้นทางนี้แล้ววันนี้',
        'student_name', v_student_name,
        'already_scanned', true
    );
END IF;
```

#### 2.2 โครงสร้างตาราง pickup_dropoff
```sql
CREATE TABLE public.pickup_dropoff (
    record_id integer PRIMARY KEY,
    student_id integer NOT NULL,
    driver_id integer NOT NULL,
    event_time timestamp with time zone NOT NULL DEFAULT now(),
    event_type text NOT NULL CHECK (event_type = ANY (ARRAY['pickup'::text, 'dropoff'::text, 'absent'::text])),
    location_type text NOT NULL CHECK (location_type = ANY (ARRAY['go'::text, 'return'::text, 'unknown'::text])),
    event_local_date date DEFAULT ((event_time AT TIME ZONE 'Asia/Bangkok'))::date,
    scan_method text DEFAULT 'rfid'::text CHECK (scan_method = ANY (ARRAY['rfid'::text, 'manual'::text, 'qr_code'::text, 'nfc'::text]))
);
```

### 3. การจัดการในระดับแอปพลิเคชัน (Application Level)

#### 3.1 การตรวจสอบ Already Scanned Status
```javascript
// ตรวจสอบว่าเป็น duplicate scan หรือไม่
if (alreadyScanned || errorMsg.indexOf("duplicate key") >= 0 || 
    errorMsg.indexOf("student_boarding_unique_daily_phase") >= 0) {
    Serial.printf("[API] ⚠️  Already Scanned: %s\n", studentName.c_str());
    Serial.printf("[API] ℹ️  นักเรียนได้สแกนบัตรในเส้นทาง %s แล้ววันนี้\n", CURRENT_TRIP_PHASE.c_str());
    return true; // ถือว่าสำเร็จเพราะนักเรียนได้ขึ้นรถแล้ว
}
```

#### 3.2 การจัดการ Event Type Logic
```javascript
// ตรวจสอบการสแกนล่าสุดเพื่อกำหนด event type
if (last) {
    if (last.event_type === 'pickup') {
        newEventType = 'dropoff'; // ถ้าขึ้นล่าสุด ครั้งนี้คือลง
        currentLocationStatus = last.location_type === 'go' ? 'school' : 'home';
    } else if (last.event_type === 'dropoff') {
        newEventType = 'pickup'; // ถ้าลงล่าสุด ครั้งนี้คือขึ้น
        currentLocationStatus = last.location_type === 'go' ? 'school' : 'home';
    }
}
```

## ระบบการจัดการขึ้น-ลงรถ

### หลักการทำงาน
1. **ขาไป (Go Phase):** นักเรียนสแกนบัตรเพื่อขึ้นรถที่บ้าน และลงรถที่โรงเรียน
2. **ขากลับ (Return Phase):** นักเรียนสแกนบัตรเพื่อขึ้นรถที่โรงเรียน และลงรถที่บ้าน
3. **การลงรถ:** คนขับเป็นผู้กดปุ่มลงรถให้นักเรียน (ไม่ใช้ RFID)

### การป้องกันการสแกนซ้ำ
- **ระดับฮาร์ดแวร์:** ป้องกันการสแกนบัตรเดิมซ้ำในระยะเวลาสั้น
- **ระดับฐานข้อมูล:** ตรวจสอบการสแกนซ้ำในวันเดียวกันและเส้นทางเดียวกัน
- **ระดับแอปพลิเคชัน:** จัดการ logic การขึ้น-ลงรถและแจ้งเตือนผู้ใช้

## ข้อดีของระบบ

### 1. ความแม่นยำของข้อมูล
- ป้องกันข้อมูลซ้ำซ้อนในฐานข้อมูล
- ลดความผิดพลาดจากการสแกนบัตรโดยไม่ตั้งใจ

### 2. ประสิทธิภาพของระบบ
- ลดการประมวลผลที่ไม่จำเป็น
- ประหยัดทรัพยากรเครือข่ายและฐานข้อมูล

### 3. ประสบการณ์ผู้ใช้ที่ดี
- แจ้งเตือนที่ชัดเจนเมื่อมีการสแกนซ้ำ
- ระบบยังคงทำงานได้ปกติแม้มีการสแกนซ้ำ

## การทดสอบระบบ

### 1. การทดสอบ Hardware Deduplication
```cpp
// ทดสอบการสแกนบัตรเดิมซ้ำในเวลาสั้น
// ผลลัพธ์: ระบบจะไม่ประมวลผลการสแกนครั้งที่สอง
```

### 2. การทดสอบ Database Constraint
```sql
-- ทดสอบการ insert ข้อมูลซ้ำ
-- ผลลัพธ์: ฐานข้อมูลจะส่งคืน already_scanned = true
```

### 3. การทดสอบ Application Logic
```javascript
// ทดสอบการจัดการ already_scanned status
// ผลลัพธ์: แอปพลิเคชันจะแสดงข้อความแจ้งเตือนที่เหมาะสม
```

## สรุป

ระบบป้องกันการสแกนบัตรซ้ำในรถโรงเรียนใช้หลักการป้องกันแบบหลายชั้น (Multi-layer Protection):

1. **ชั้นที่ 1 - Hardware:** ป้องกันการสแกนซ้ำในระยะเวลาสั้น
2. **ชั้นที่ 2 - Database:** ตรวจสอบและป้องกันข้อมูลซ้ำในระดับฐานข้อมูล
3. **ชั้นที่ 3 - Application:** จัดการ logic และแจ้งเตือนผู้ใช้

ระบบนี้ช่วยให้การติดตามการขึ้น-ลงรถของนักเรียนมีความแม่นยำและเชื่อถือได้ โดยมีเฉพาะการสแกนขึ้นรถเท่านั้น ส่วนการลงรถจะให้คนขับเป็นผู้กดปุ่มจัดการเอง

---

**หมายเหตุ:** เอกสารนี้จัดทำขึ้นเพื่อใช้ในการรายงานและอ้างอิงสำหรับการพัฒนาระบบ RFID รถโรงเรียนต่อไป